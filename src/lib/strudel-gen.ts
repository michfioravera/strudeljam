import { Track, INSTRUMENTS, TOTAL_STEPS } from './constants';

// Helper to convert boolean steps to mini-notation (e.g., "x . x .")
const stepsToMiniNotation = (steps: boolean[]): string => {
  if (steps.every((s) => !s)) return '~'; // Silence
  
  // Simplify: group by 4 for readability if possible, but simple mapping is fine
  // Strudel mini-notation: x = event, . = rest
  return steps.map(s => s ? 'x' : '.').join(' ');
};

export const generateStrudelCode = (tracks: Track[], bpm: number): string => {
  if (tracks.length === 0) return '// Aggiungi una traccia per iniziare\n';

  const trackLines = tracks.map(track => {
    if (track.muted) return null;
    
    const instDef = INSTRUMENTS.find(i => i.id === track.instrument);
    if (!instDef) return null;

    const pattern = stepsToMiniNotation(track.steps);
    if (pattern === '~') return null; // Don't generate code for empty tracks to keep it clean

    // Basic volume mapping (0-1 to gain)
    const gain = track.volume.toFixed(2);

    let line = `  s("${instDef.strudelName}")`;
    
    if (instDef.defaultNote) {
      line += `.note("${instDef.defaultNote}")`;
    }
    
    line += `.struct("${pattern}")`;
    
    if (track.volume < 1) {
      line += `.gain(${gain})`;
    }

    return line;
  }).filter(Boolean);

  if (trackLines.length === 0) return `// Tutte le tracce sono mute o vuote\nsetcps(${bpm/60/4})`;

  return `// Strudel Code Generated
setcps(${bpm / 60 / 4}); // ${bpm} BPM

stack(
${trackLines.join(',\n')}
).out();
`;
};

// Basic parser to try and restore state from code (Very limited scope)
// This is a "best effort" parser for the specific format we generate.
export const parseStrudelCode = (code: string): Partial<Track>[] | null => {
  try {
    // Extract BPM
    // setcps(120/60/4) or setcps(0.5)
    // We won't parse BPM back for now to avoid complexity, focusing on tracks.

    // Look for s("...")... lines
    const lines = code.split('\n');
    const parsedTracks: Partial<Track>[] = [];

    lines.forEach(line => {
      const sMatch = line.match(/s\("([^"]+)"\)/);
      if (!sMatch) return;

      const strudelName = sMatch[1];
      const instDef = INSTRUMENTS.find(i => i.strudelName === strudelName);
      if (!instDef) return;

      const structMatch = line.match(/\.struct\("([^"]+)"\)/);
      const pattern = structMatch ? structMatch[1] : "";
      
      // Parse pattern "x . x ." back to booleans
      // This assumes simple space separated chars
      const rawSteps = pattern.replace(/\s+/g, '').split('');
      const steps = Array(TOTAL_STEPS).fill(false);
      
      // Map back to 16 steps (simple mapping)
      // If pattern is shorter/longer, we just fill what we can or repeat. 
      // For this simple app, we assume 1:1 mapping if generated by us.
      for (let i = 0; i < Math.min(rawSteps.length, TOTAL_STEPS); i++) {
        steps[i] = rawSteps[i] === 'x';
      }

      // Volume
      const gainMatch = line.match(/\.gain\(([\d.]+)\)/);
      const volume = gainMatch ? parseFloat(gainMatch[1]) : 1;

      parsedTracks.push({
        id: Math.random().toString(36).substr(2, 9), // New ID
        instrument: instDef.id,
        steps,
        volume,
        muted: false
      });
    });

    return parsedTracks.length > 0 ? parsedTracks : null;
  } catch (e) {
    console.error("Failed to parse code", e);
    return null;
  }
};
